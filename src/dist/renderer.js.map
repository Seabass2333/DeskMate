{"version":3,"file":"renderer.js","sources":["../core/BehaviorEngine.ts","../core/TriggerScheduler.ts","../audio/SoundManager.ts","../core/EnergyManager.ts","../features/DragController.ts","../renderer.ts"],"sourcesContent":["/**\n * BehaviorEngine - Configuration-driven pet behavior management\n * \n * Features:\n * - Dynamic state management from skin config\n * - Weighted random idle actions\n * - Event-based architecture\n * - Quiet mode support\n * - Auto-revert timers\n * \n * @module core/BehaviorEngine\n */\n\nimport type {\n    BehaviorConfig,\n    BehaviorEvent,\n    BehaviorEventType,\n    BehaviorEventListener,\n    IdleAction,\n    StateTransition,\n    DEFAULT_BEHAVIOR_CONFIG\n} from '../types/behavior';\n\n// Re-define default here to avoid circular dependency issues with .d.ts\nconst DEFAULT_CONFIG: BehaviorConfig = {\n    states: ['idle', 'sleep', 'drag', 'working', 'thinking', 'interact', 'dance'],\n    idleActions: [\n        { state: 'sleep', weight: 30, duration: 4000 },\n        { state: 'dance', weight: 20, duration: 4000 },\n        { state: 'interact', weight: 20, duration: 4000 }\n    ],\n    idleTimeout: {\n        min: 10000,\n        max: 30000\n    },\n    interactions: {\n        click: { state: null },\n        drag: { state: 'drag' }\n    }\n};\n\n/**\n * BehaviorEngine manages pet state and behavior based on skin configuration.\n * Replaces the hardcoded StateMachine with a data-driven approach.\n * \n * @example\n * ```typescript\n * const engine = new BehaviorEngine(skinConfig.behaviors);\n * engine.on('stateChange', (e) => animation.play(e.data.to));\n * engine.transition('sleep');\n * ```\n */\nexport class BehaviorEngine {\n    private config: BehaviorConfig;\n    private currentState: string = 'idle';\n    private previousState: string | null = null;\n    private quietMode: boolean = false;\n\n    // Timers\n    private idleTimer: ReturnType<typeof setTimeout> | null = null;\n    private revertTimer: ReturnType<typeof setTimeout> | null = null;\n\n    // Event listeners\n    private listeners: Map<BehaviorEventType, Set<BehaviorEventListener>> = new Map();\n\n    /**\n     * Create a BehaviorEngine with optional behavior configuration\n     * \n     * @param config - Behavior configuration from skin, uses defaults if not provided\n     */\n    constructor(config?: BehaviorConfig) {\n        this.config = config ?? DEFAULT_CONFIG;\n\n        // Ensure 'idle' is always in states\n        if (!this.config.states.includes('idle')) {\n            this.config.states.unshift('idle');\n        }\n\n        // Initialize listener maps\n        this.listeners.set('stateChange', new Set());\n        this.listeners.set('soundPlay', new Set());\n        this.listeners.set('actionTriggered', new Set());\n    }\n\n    // ========== State Management ==========\n\n    /**\n     * Get current state\n     */\n    getCurrentState(): string {\n        return this.currentState;\n    }\n\n    /**\n     * Get previous state\n     */\n    getPreviousState(): string | null {\n        return this.previousState;\n    }\n\n    /**\n     * Get all valid states for this behavior config\n     */\n    getValidStates(): string[] {\n        return [...this.config.states];\n    }\n\n    /**\n     * Transition to a new state\n     * \n     * @param newState - State to transition to\n     * @returns true if transition successful, false otherwise\n     */\n    transition(newState: string): boolean {\n        // Validate state\n        if (!this.config.states.includes(newState)) {\n            console.warn(`[BehaviorEngine] Invalid state: ${newState}`);\n            return false;\n        }\n\n        // Strict Quiet Mode: Block all transitions except TO 'sleep'\n        if (this.quietMode && newState !== 'sleep') {\n            console.log(`[BehaviorEngine] Transition blocked by Quiet Mode: ${newState}`);\n            return false;\n        }\n\n        // Skip if same state, UNLESS it's a non-idle state (e.g. interact) \n        // which implies the user wants to re-trigger the action/sound/timer\n        if (this.currentState === newState && newState === 'idle') {\n            return true;\n        }\n\n        // Perform transition (or re-entry)\n        const isReentry = this.currentState === newState;\n        this.previousState = this.currentState;\n        this.currentState = newState;\n\n        // Emit event (force timestamp update to distinguish events)\n        this.emit('stateChange', {\n            from: this.previousState,\n            to: newState,\n            timestamp: Date.now()\n        });\n\n        if (!isReentry) {\n            console.log(`[BehaviorEngine] ${this.previousState} -> ${newState}`);\n        } else {\n            // console.log(`[BehaviorEngine] Re-entry: ${newState}`);\n        }\n\n        // Reset idle timer if transitioning back to idle\n        if (newState === 'idle' && !this.quietMode) {\n            this.scheduleIdleAction();\n        } else if (newState !== 'idle' && !this.quietMode) {\n            // Check if this state has a duration (transient state)\n            // Look up in idleActions config\n            const actionConfig = this.config.idleActions?.find(a => a.state === newState);\n            if (actionConfig?.duration) {\n                console.log(`[BehaviorEngine] Auto-revert scheduled for ${newState}: ${actionConfig.duration}ms`);\n                this.scheduleRevert(actionConfig.duration);\n            }\n\n            // Safety Fallback: Interactive states should NEVER stick\n            // If configuration lookup failed but we are in a known transient state, enforce revert\n            if (!this.revertTimer && ['interact', 'dance', 'submissive', 'angry'].includes(newState)) {\n                console.warn(`[BehaviorEngine] Safety Revert triggered for stuck state: ${newState}`);\n                this.scheduleRevert(3000);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Revert to previous state (or idle if none)\n     */\n    revert(): void {\n        const targetState = this.previousState ?? 'idle';\n        this.transition(targetState);\n    }\n\n    // ========== Quiet Mode ==========\n\n    /**\n     * Enable or disable quiet mode\n     * In quiet mode, pet sleeps and no random actions trigger\n     * \n     * @param enabled - Whether to enable quiet mode\n     */\n    setQuietMode(enabled: boolean): void {\n        this.quietMode = enabled;\n        console.log(`[BehaviorEngine] Quiet mode: ${enabled ? 'ON' : 'OFF'}`);\n\n        if (enabled) {\n            // Go to sleep, stop all timers\n            this.clearTimers();\n            if (this.currentState !== 'sleep' && this.config.states.includes('sleep')) {\n                this.transition('sleep');\n            }\n        } else {\n            // Wake up\n            if (this.currentState === 'sleep') {\n                this.transition('idle');\n            }\n        }\n    }\n\n    /**\n     * Check if quiet mode is enabled\n     */\n    isQuietMode(): boolean {\n        return this.quietMode;\n    }\n\n    // ========== Idle Timer ==========\n\n    /**\n     * Start the idle action timer\n     */\n    startIdleTimer(): void {\n        if (this.quietMode) return;\n        this.scheduleIdleAction();\n    }\n\n    /**\n     * Schedule a random idle action\n     */\n    private scheduleIdleAction(): void {\n        this.clearIdleTimer();\n\n        if (this.quietMode || this.currentState !== 'idle') return;\n\n        const { min, max } = this.config.idleTimeout ?? { min: 10000, max: 30000 };\n        const delay = Math.random() * (max - min) + min;\n\n        this.idleTimer = setTimeout(() => {\n            this.triggerRandomAction();\n        }, delay);\n    }\n\n    /**\n     * Trigger a weighted random idle action\n     */\n    private triggerRandomAction(): void {\n        if (this.quietMode || this.currentState !== 'idle') return;\n\n        const actions = this.config.idleActions;\n        if (!actions || actions.length === 0) return;\n\n        // Weighted random selection\n        const action = this.pickWeightedAction(actions);\n        if (!action) return;\n\n        // Emit event\n        this.emit('actionTriggered', { action });\n\n        // Transition to action state\n        this.transition(action.state);\n\n        // Schedule auto-revert\n        if (action.duration) {\n            this.scheduleRevert(action.duration);\n        }\n    }\n\n    /**\n     * Pick a random action based on weights\n     */\n    private pickWeightedAction(actions: IdleAction[]): IdleAction | null {\n        const totalWeight = actions.reduce((sum, a) => sum + a.weight, 0);\n        let random = Math.random() * totalWeight;\n\n        for (const action of actions) {\n            if (random < action.weight) {\n                return action;\n            }\n            random -= action.weight;\n        }\n\n        return actions[0];\n    }\n\n    /**\n     * Schedule a revert to idle after duration\n     */\n    private scheduleRevert(duration: number): void {\n        this.clearRevertTimer();\n\n        this.revertTimer = setTimeout(() => {\n            if (this.currentState !== 'idle') {\n                this.transition('idle');\n            }\n        }, duration);\n    }\n\n    // ========== Event System ==========\n\n    /**\n     * Subscribe to an event\n     * \n     * @param event - Event type to listen to\n     * @param listener - Callback function\n     */\n    on(event: BehaviorEventType, listener: BehaviorEventListener): void {\n        this.listeners.get(event)?.add(listener);\n    }\n\n    /**\n     * Unsubscribe from an event\n     * \n     * @param event - Event type\n     * @param listener - Callback to remove\n     */\n    off(event: BehaviorEventType, listener: BehaviorEventListener): void {\n        this.listeners.get(event)?.delete(listener);\n    }\n\n    /**\n     * Emit an event to all listeners\n     */\n    private emit(type: BehaviorEventType, data: StateTransition | { soundId: string } | { action: IdleAction }): void {\n        const event: BehaviorEvent = { type, data };\n        this.listeners.get(type)?.forEach(listener => listener(event));\n    }\n\n    // ========== Cleanup ==========\n\n    /**\n     * Clear all timers\n     */\n    private clearTimers(): void {\n        this.clearIdleTimer();\n        this.clearRevertTimer();\n    }\n\n    private clearIdleTimer(): void {\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n            this.idleTimer = null;\n        }\n    }\n\n    private clearRevertTimer(): void {\n        if (this.revertTimer) {\n            clearTimeout(this.revertTimer);\n            this.revertTimer = null;\n        }\n    }\n\n    /**\n     * Clean up all resources\n     */\n    dispose(): void {\n        this.clearTimers();\n        this.listeners.forEach(set => set.clear());\n    }\n}\n","/**\n * TriggerScheduler - Condition-based action trigger system\n * \n * Features:\n * - Evaluate conditions at regular intervals\n * - Support for time, idleTime, and custom context variables\n * - Integration with BehaviorEngine for state transitions\n * - Safe expression evaluation\n * \n * @module core/TriggerScheduler\n */\n\nimport type { BehaviorTrigger, BehaviorAction } from '../types/behavior';\nimport type { BehaviorEngine } from './BehaviorEngine';\n\n/**\n * Context variables available for condition evaluation\n */\ninterface TriggerContext {\n    /** Milliseconds since last user interaction */\n    idleTime: number;\n    /** Current energy level (0-100) */\n    energy: number;\n    /** Current hour (0-23) */\n    hour: number;\n    /** Current minute (0-59) */\n    minute: number;\n    /** Day of week (0-6, 0=Sunday) */\n    dayOfWeek: number;\n    /** Custom context values */\n    [key: string]: number | boolean | string;\n}\n\n/**\n * TriggerScheduler evaluates conditions periodically and triggers actions.\n * \n * @example\n * ```typescript\n * const scheduler = new TriggerScheduler(engine, config.triggers);\n * scheduler.start(60000); // Evaluate every minute\n * scheduler.setContext({ energy: 50 });\n * ```\n */\nexport class TriggerScheduler {\n    private engine: BehaviorEngine;\n    private triggers: BehaviorTrigger[];\n    private context: Partial<TriggerContext> = {};\n    private intervalId: ReturnType<typeof setInterval> | null = null;\n    private running: boolean = false;\n\n    /**\n     * Create a TriggerScheduler\n     * \n     * @param engine - BehaviorEngine to control\n     * @param triggers - Array of trigger configurations\n     */\n    constructor(engine: BehaviorEngine, triggers: BehaviorTrigger[]) {\n        this.engine = engine;\n        this.triggers = this.mergeWithDefaults(triggers);\n        this.resetIdleTime();\n    }\n\n    /**\n     * Merge user triggers with system defaults\n     */\n    private mergeWithDefaults(userTriggers: BehaviorTrigger[]): BehaviorTrigger[] {\n        // Default System Triggers (Phase 17)\n        const defaults: BehaviorTrigger[] = [\n            // Night Mode: 23:00 - 06:00 -> Force Sleep\n            {\n                condition: \"hour >= 23 || hour < 6\",\n                action: { state: \"sleep\", duration: 600000 } // 10 min sleep blocks\n            },\n            // Low Energy: < 10 -> Force Sleep\n            {\n                condition: \"energy < 10\",\n                action: { state: \"sleep\", duration: 60000 }\n            },\n            // Tired: < 30 -> Force Tired/Sleep\n            {\n                condition: \"energy < 30\",\n                action: { state: \"sleep\", duration: 30000 }\n            }\n        ];\n\n        // User triggers take precedence if we want to allow override, \n        // but for now we append defaults to ensure basic needs are met.\n        // Triggers are evaluated in order, so we put system triggers LAST \n        // to let specific skin behaviors override them if defined first.\n        return [...userTriggers, ...defaults];\n    }\n\n    // ========== Lifecycle ==========\n\n    /**\n     * Start the evaluation loop\n     * \n     * @param intervalMs - Evaluation interval in milliseconds (default: 60000)\n     */\n    start(intervalMs: number = 60000): void {\n        if (this.running) return;\n\n        this.running = true;\n        this.intervalId = setInterval(() => {\n            this.evaluate();\n        }, intervalMs);\n\n        console.log(`[TriggerScheduler] Started with ${intervalMs}ms interval`);\n    }\n\n    /**\n     * Stop the evaluation loop\n     */\n    stop(): void {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n            this.intervalId = null;\n        }\n        this.running = false;\n        console.log('[TriggerScheduler] Stopped');\n    }\n\n    /**\n     * Check if scheduler is running\n     */\n    isRunning(): boolean {\n        return this.running;\n    }\n\n    /**\n     * Clean up all resources\n     */\n    dispose(): void {\n        this.stop();\n        this.context = {};\n    }\n\n    // ========== Context Management ==========\n\n    /**\n     * Update context values\n     * \n     * @param values - Partial context to merge\n     */\n    setContext(values: Partial<TriggerContext>): void {\n        this.context = { ...this.context, ...values };\n    }\n\n    /**\n     * Get a context value\n     * \n     * @param key - Context key\n     */\n    getContext(key: string): number | boolean | string | undefined {\n        return this.context[key];\n    }\n\n    /**\n     * Reset idle time to 0\n     */\n    resetIdleTime(): void {\n        this.context.idleTime = 0;\n    }\n\n    // ========== Evaluation ==========\n\n    /**\n     * Evaluate all triggers and execute first matching action\n     */\n    evaluate(): void {\n        // Update time-based context\n        const now = new Date();\n        this.context.hour = now.getHours();\n        this.context.minute = now.getMinutes();\n        this.context.dayOfWeek = now.getDay();\n\n        // Evaluate triggers in order (first match wins)\n        for (const trigger of this.triggers) {\n            if (this.evaluateCondition(trigger.condition)) {\n                this.executeAction(trigger.action);\n                return; // Only execute first matching trigger\n            }\n        }\n    }\n\n    /**\n     * Safely evaluate a condition expression\n     * \n     * @param condition - Condition string (e.g., \"idleTime > 5000\")\n     */\n    private evaluateCondition(condition: string): boolean {\n        try {\n            // Build context object for evaluation\n            const ctx = {\n                idleTime: this.context.idleTime ?? 0,\n                energy: this.context.energy ?? 100,\n                hour: this.context.hour ?? new Date().getHours(),\n                minute: this.context.minute ?? new Date().getMinutes(),\n                dayOfWeek: this.context.dayOfWeek ?? new Date().getDay(),\n                ...this.context\n            };\n\n            // Safe evaluation using Function constructor\n            // Only allows simple comparison operators and logical operators\n            const safeCondition = this.sanitizeCondition(condition);\n            const fn = new Function(...Object.keys(ctx), `return ${safeCondition};`);\n\n            return Boolean(fn(...Object.values(ctx)));\n        } catch (error) {\n            console.warn(`[TriggerScheduler] Failed to evaluate condition: ${condition}`, error);\n            return false;\n        }\n    }\n\n    /**\n     * Sanitize condition to prevent code injection\n     * Only allows: numbers, operators, parentheses, and known variable names\n     */\n    private sanitizeCondition(condition: string): string {\n        // Allowed patterns: variable names, numbers, operators\n        const allowedPattern = /^[\\w\\s<>=!&|()+-]+$/;\n\n        if (!allowedPattern.test(condition)) {\n            throw new Error(`Invalid condition: ${condition}`);\n        }\n\n        return condition;\n    }\n\n    /**\n     * Execute a trigger action\n     */\n    private executeAction(action: BehaviorAction): void {\n        console.log(`[TriggerScheduler] Executing action:`, action);\n\n        if (action.state) {\n            this.engine.transition(action.state);\n        }\n\n        // Sound playback would be handled by event listener\n        if (action.sound) {\n            // Emit event for SoundManager to handle\n            // This coupling is intentionally loose - scheduler just sets state\n        }\n    }\n}\n","/**\n * SoundManager - Manages audio playback for pet sounds\n * \n * Features:\n * - Load multiple sounds from skin configuration\n * - Play one-shot sounds\n * - Manage looping ambient sounds\n * - Graceful error handling\n * \n * @module audio/SoundManager\n */\n\nimport type {\n    SkinSounds,\n    SoundRef,\n    NormalizedSoundConfig\n} from '../types/sound';\n\n/**\n * Internal sound entry with Audio element and config\n */\ninterface SoundEntry {\n    audio: HTMLAudioElement;\n    config: NormalizedSoundConfig;\n}\n\n/**\n * SoundManager handles all audio playback for a pet skin.\n * Supports both simple sound references and complex configurations.\n * \n * @example\n * ```typescript\n * const sm = new SoundManager();\n * await sm.loadSounds({ click: 'meow.mp3' }, '/assets/skins/mochi');\n * await sm.play('click');\n * ```\n */\nexport class SoundManager {\n    /** Map of sound ID to entry */\n    private sounds: Map<string, SoundEntry> = new Map();\n\n    /** Currently looping sound ID (Ambience Channel) */\n    private currentAmbienceId: string | null = null;\n\n    /** Currently playing SFX Audio (SFX Channel) */\n    private activeSfx: HTMLAudioElement | null = null;\n\n    /** Global Mute State */\n    private muted: boolean = false;\n\n    /**\n     * Load sounds from skin configuration\n     * Clears any previously loaded sounds\n     * \n     * @param soundConfig - Sound configuration from skin config.json\n     * @param basePath - Base path to skin folder\n     */\n    async loadSounds(soundConfig: SkinSounds, basePath: string): Promise<void> {\n        // Clean up existing sounds\n        this.dispose();\n\n        // Load each sound\n        for (const [id, ref] of Object.entries(soundConfig)) {\n            if (ref === undefined) continue;\n\n            const normalized = this.normalizeConfig(ref, basePath);\n            const audio = this.createAudioElement(normalized);\n\n            this.sounds.set(id, { audio, config: normalized });\n        }\n\n\n\n        console.log(`[SoundManager] Loaded ${this.sounds.size} sounds`);\n    }\n\n    /**\n     * Set global mute state\n     * Stops all sounds if muted\n     */\n    setMuted(muted: boolean): void {\n        this.muted = muted;\n        console.log(`[SoundManager] Global Mute: ${muted}`);\n        if (muted) {\n            this.stopLoop();\n            // Stop any active SFX if we were tracking them (we currently don't track persistent SFX references well, \n            // but short SFX usually don't need force stop. If needed, we can track them).\n        }\n    }\n\n    /**\n     * Play a sound by ID (one-shot)\n     * \n     * @param soundId - Sound identifier\n     * @returns true if played successfully, false otherwise\n     */\n    async play(soundId: string): Promise<boolean> {\n        if (this.muted) return false;\n        const entry = this.sounds.get(soundId);\n        if (!entry) {\n            console.warn(`[SoundManager] Sound not found: ${soundId}`);\n            return false;\n        }\n\n        try {\n            // Randomize source if variations exist\n            if (entry.config.srcs && entry.config.srcs.length > 1) {\n                const newSrc = entry.config.srcs[Math.floor(Math.random() * entry.config.srcs.length)];\n                entry.audio.src = newSrc;\n            }\n\n            // Reset to start for re-play\n            entry.audio.currentTime = 0;\n            console.log(`[SoundManager] Attempting to play: ${soundId} (${entry.audio.src})`);\n            const promise = entry.audio.play();\n\n            if (promise !== undefined) {\n                promise.then(() => {\n                    console.log(`[SoundManager] Playing: ${soundId}`);\n                }).catch(error => {\n                    console.error(`[SoundManager] Play failed for ${soundId}:`, error);\n                });\n            }\n            return true;\n        } catch (error) {\n            console.error(`[SoundManager] Play failed for ${soundId}:`, error);\n            return false;\n        }\n    }\n\n    /** Ambience Loop Timer */\n    private ambienceTimer: number | null = null;\n\n    /**\n     * Start a looping sound (Ambience)\n     * Stops any currently looping sound first\n     * \n     * @param soundId - Sound identifier\n     * @returns true if started successfully\n     */\n    async loop(soundId: string): Promise<boolean> {\n        if (this.muted) return false;\n        // Stop current loop if any\n        this.stopLoop();\n\n        const entry = this.sounds.get(soundId);\n        if (!entry) {\n            console.warn(`[SoundManager] Sound not found: ${soundId}`);\n            return false;\n        }\n\n        this.currentAmbienceId = soundId;\n        const audio = entry.audio;\n        const config = entry.config;\n\n        // Handler for intermittent loops\n        const playNext = async () => {\n            if (this.currentAmbienceId !== soundId) return; // Stop if changed\n\n            try {\n                audio.currentTime = 0;\n                await audio.play();\n            } catch (err) {\n                console.warn('[SoundManager] Ambience play error:', err);\n            }\n        };\n\n        if (config.loopDelay) {\n            // Intermittent Loop\n            audio.loop = false; // Native loop OFF\n\n            // Cleanup old listeners if any (though we usually create fresh audio, \n            // but here we reuse entry.audio, so we must be careful with 'ended' listeners)\n            // Ideally we'd wrap this cleanly, but for now:\n            audio.onended = () => {\n                if (this.currentAmbienceId !== soundId) return;\n\n                const delay = Math.random() * (config.loopDelay!.max - config.loopDelay!.min) + config.loopDelay!.min;\n                this.ambienceTimer = window.setTimeout(playNext, delay);\n            };\n\n            await playNext(); // Start first play\n        } else {\n            // Standard continuous loop\n            try {\n                audio.loop = true;\n                audio.onended = null; // Clear listener\n                audio.currentTime = 0;\n                await audio.play();\n            } catch (error) {\n                console.error(`[SoundManager] Loop failed for ${soundId}:`, error);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Stop the currently looping sound\n     */\n    stopLoop(): void {\n        // Clear timer\n        if (this.ambienceTimer) {\n            clearTimeout(this.ambienceTimer);\n            this.ambienceTimer = null;\n        }\n\n        if (this.currentAmbienceId) {\n            const entry = this.sounds.get(this.currentAmbienceId);\n            if (entry) {\n                entry.audio.pause();\n                entry.audio.currentTime = 0;\n                entry.audio.loop = false;\n                entry.audio.onended = null; // Clear intermittent listener\n            }\n            this.currentAmbienceId = null;\n        }\n    }\n\n    /**\n     * Check if a sound is currently looping\n     * \n     * @param soundId - Sound identifier\n     */\n    isLooping(soundId: string): boolean {\n        return this.currentAmbienceId === soundId;\n    }\n\n    /**\n     * Get all loaded sound IDs\n     */\n    getSoundIds(): string[] {\n        return Array.from(this.sounds.keys());\n    }\n\n    /**\n     * Get normalized config for a sound\n     * Used for testing and debugging\n     * \n     * @param soundId - Sound identifier\n     */\n    getConfig(soundId: string): NormalizedSoundConfig | null {\n        return this.sounds.get(soundId)?.config ?? null;\n    }\n\n    /**\n     * Clean up all audio resources\n     */\n    dispose(): void {\n        this.stopLoop();\n\n        for (const entry of this.sounds.values()) {\n            entry.audio.pause();\n            entry.audio.src = '';\n        }\n\n        this.sounds.clear();\n        this.activeSfx = null;\n        this.currentAmbienceId = null;\n    }\n\n    // ========== Private Methods ==========\n\n    /**\n     * Normalize a sound reference to full config\n     */\n    private normalizeConfig(ref: SoundRef, basePath: string): NormalizedSoundConfig {\n        // String array: Random variations\n        if (Array.isArray(ref)) {\n            // Pick random one to start, but store all\n            // Ideally we'd store the list and pick on play, \n            // but for simple normalization we map to a list-capable config\n            // Note: The type system needs update to support 'srcs'.\n            // For now, we'll pick one random source for the initial element\n            // A better architecture would perform randomization at play time.\n\n            // Actually, let's just pick one random one for now to keep type compatibility simple,\n            // or better: treat string[] as multiple valid sources.\n            // But wait, Audio element takes one src.\n            // To support variations properly, we need to change how we store sounds.\n            // Let's modify the Entry to hold a list of sources.\n            return {\n                src: `${basePath}/${ref[0]}`, // Fallback compliant\n                srcs: ref.map(r => `${basePath}/${r}`), // New property\n                loop: false,\n                volume: 1,\n                playbackRate: 1\n            };\n        }\n\n        if (typeof ref === 'string') {\n            return {\n                src: `${basePath}/${ref}`,\n                loop: false,\n                volume: 1,\n                playbackRate: 1\n            };\n        }\n\n        return {\n            src: `${basePath}/${ref.src}`,\n            srcs: ref.srcs?.map(r => `${basePath}/${r}`), // Handle array in config object too if present\n            loop: ref.loop ?? false,\n            loopDelay: ref.loopDelay,\n            volume: ref.volume ?? 1,\n            playbackRate: ref.playbackRate ?? 1\n        };\n    }\n\n    /**\n     * Create and configure an Audio element\n     */\n    private createAudioElement(config: NormalizedSoundConfig): HTMLAudioElement {\n        // If config has multiple sources, pick one random\n        let src = config.src;\n        if (config.srcs && config.srcs.length > 0) {\n            src = config.srcs[Math.floor(Math.random() * config.srcs.length)];\n        }\n\n        const audio = new Audio(src);\n        audio.volume = config.volume;\n        audio.playbackRate = config.playbackRate;\n        audio.loop = config.loop;\n\n        // Debug listeners\n        audio.addEventListener('error', (e) => {\n            console.error(`[SoundManager] Audio Error for ${src}:`, e, audio.error);\n        });\n        audio.addEventListener('canplay', () => {\n            console.log(`[SoundManager] Audio loaded: ${src.split('/').pop()}`);\n        });\n\n        return audio;\n    }\n}\n","/**\n * Energy Manager - Handles pet energy/mood system\n * Migrated to TypeScript for Phase 17\n * \n * @module core/EnergyManager\n */\n\n// Energy Tiers Configuration\ninterface EnergyTier {\n    min: number;\n    max: number;\n    animations: string[];\n}\n\nconst ENERGY_TIERS: Record<string, EnergyTier> = {\n    exhausted: { min: 0, max: 10, animations: ['Dead', 'Dead1', 'Dead2'] },\n    tired: { min: 11, max: 30, animations: ['Sleeping'] },\n    relaxed: { min: 31, max: 50, animations: ['Chilling', 'Idle'] },\n    normal: { min: 51, max: 70, animations: ['Idle', 'Happy'] },\n    energetic: { min: 71, max: 85, animations: ['Happy', 'Excited'] },\n    hyper: { min: 86, max: 100, animations: ['Dance', 'Excited', 'Running'] }\n};\n\nexport class EnergyManager {\n    private energy: number = 75;\n    private lastUpdate: number = Date.now();\n    private decayInterval: number | null = null;\n\n    // Constants\n    private readonly DECAY_RATE = 1;\n    private readonly DECAY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\n    private readonly MIN_ENERGY = 5;\n    private readonly MAX_ENERGY = 100;\n\n    // Event listeners\n    private listeners: Map<string, Array<(data: any) => void>> = new Map();\n\n    constructor() {\n    }\n\n    /**\n     * Subscribe to events\n     */\n    on(event: string, callback: (data: any) => void): void {\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, []);\n        }\n        this.listeners.get(event)?.push(callback);\n    }\n\n    /**\n     * Remove event listener\n     */\n    off(event: string, callback: (data: any) => void): void {\n        const callbacks = this.listeners.get(event);\n        if (callbacks) {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1) {\n                callbacks.splice(index, 1);\n            }\n        }\n    }\n\n    /**\n     * Emit event\n     */\n    private emit(event: string, data: any): void {\n        const callbacks = this.listeners.get(event);\n        if (callbacks) {\n            callbacks.forEach(callback => {\n                try {\n                    callback(data);\n                } catch (err) {\n                    console.error(`[EnergyManager] Error in event listener for ${event}:`, err);\n                }\n            });\n        }\n    }\n\n    /**\n     * Initialize energy system\n     * Loads saved state and catches up decay\n     */\n    async init(): Promise<void> {\n        try {\n            const state = await window.deskmate.getPetState();\n            this.energy = state?.energy ?? 75;\n            this.lastUpdate = new Date(state?.lastEnergyUpdate || Date.now()).getTime();\n\n            // Catch up decay if app was closed\n            const timeSinceLastUpdate = Date.now() - this.lastUpdate;\n            const decayIntervals = Math.floor(timeSinceLastUpdate / this.DECAY_INTERVAL_MS);\n\n            if (decayIntervals > 0) {\n                const decayAmount = decayIntervals * this.DECAY_RATE;\n                this.energy = Math.max(this.MIN_ENERGY, this.energy - decayAmount);\n                await this.save();\n            }\n\n            this.startDecayTimer();\n            this.updateUI();\n            this.emit('energyChange', this.energy);\n\n            console.log(`[EnergyManager] Initialized with energy: ${this.energy}`);\n        } catch (error) {\n            console.warn('[EnergyManager] Init error:', error);\n        }\n    }\n\n    /**\n     * Start the background decay timer\n     */\n    private startDecayTimer(): void {\n        // Clear existing if any\n        if (this.decayInterval) {\n            clearInterval(this.decayInterval);\n        }\n\n        // Use window.setInterval to avoid Node.js/browser Timer type conflict issues\n        this.decayInterval = window.setInterval(() => {\n            this.modifyEnergy(-this.DECAY_RATE);\n            console.log(`[EnergyManager] Decay: energy now ${this.energy}`);\n        }, this.DECAY_INTERVAL_MS);\n    }\n\n    /**\n     * Modify energy level\n     * @param delta Amount to change (-/+)\n     * @returns New energy level\n     */\n    async modifyEnergy(delta: number): Promise<number> {\n        const oldTier = this.getTier();\n\n        this.energy = Math.max(this.MIN_ENERGY, Math.min(this.MAX_ENERGY, this.energy + delta));\n        this.lastUpdate = Date.now();\n\n        this.updateUI();\n        await this.save();\n\n        // Emit events\n        this.emit('energyChange', this.energy);\n\n        const newTier = this.getTier();\n        if (oldTier !== newTier) {\n            this.emit('tierChange', newTier);\n        }\n\n        return this.energy;\n    }\n\n    /**\n     * Save state to persistence layer\n     */\n    private async save(): Promise<void> {\n        try {\n            const petState = await window.deskmate.getPetState() || {};\n            petState.energy = this.energy;\n            petState.lastEnergyUpdate = new Date().toISOString();\n            await window.deskmate.savePetState(petState);\n        } catch (error) {\n            console.warn('[EnergyManager] Save error:', error);\n        }\n    }\n\n    /**\n     * Get current energy tier name\n     */\n    getTier(): string {\n        for (const [tierName, tierData] of Object.entries(ENERGY_TIERS)) {\n            if (this.energy >= tierData.min && this.energy <= tierData.max) {\n                return tierName;\n            }\n        }\n        return 'normal';\n    }\n\n    /**\n     * Get localized status message based on tier\n     */\n    async getStatusMessage(): Promise<string> {\n        const tier = this.getTier();\n        switch (tier) {\n            case 'hyper': return await window.deskmate.t('statusHyper');\n            case 'energetic': return await window.deskmate.t('statusEnergetic');\n            case 'normal': return await window.deskmate.t('statusNormal');\n            case 'tired': return await window.deskmate.t('statusTired');\n            case 'exhausted': return await window.deskmate.t('statusExhausted');\n            default: return await window.deskmate.t('statusMeow');\n        }\n    }\n\n    /**\n     * Get current energy value\n     */\n    getEnergy(): number {\n        return this.energy;\n    }\n\n    /**\n     * Update UI elements (Energy Bar)\n     */\n    private updateUI(): void {\n        const bar = document.getElementById('energy-bar');\n        if (!bar) return;\n\n        // Update width\n        bar.style.width = `${this.energy}%`;\n\n        // Update color class based on tier\n        bar.classList.remove('tired', 'energetic');\n        const tier = this.getTier();\n        if (tier === 'exhausted' || tier === 'tired') {\n            bar.classList.add('tired');\n        } else if (tier === 'energetic' || tier === 'hyper') {\n            bar.classList.add('energetic');\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    dispose(): void {\n        if (this.decayInterval) {\n            clearInterval(this.decayInterval);\n            this.decayInterval = null;\n        }\n        this.listeners.clear();\n    }\n}\n","/**\n * Drag Controller - Handles pet dragging and click interactions\n * Migrated to TypeScript for Phase 17\n * \n * @module features/DragController\n */\n\ninterface Point {\n    x: number;\n    y: number;\n}\n\nexport class DragController {\n    private character: HTMLElement;\n    private isDragging: boolean = false;\n    private hasMoved: boolean = false;\n\n    // Position tracking\n    private startMouse: Point = { x: 0, y: 0 };\n    private startWin: Point = { x: 0, y: 0 };\n\n    // Dependencies\n    // Note: In legacy mode we received StateMachine, but now we use module imports or global access\n    private stateMachine: any;\n\n    constructor(stateMachine?: any) {\n        this.stateMachine = stateMachine;\n\n        const el = document.getElementById('character');\n        if (!el) throw new Error('Character element not found');\n        this.character = el;\n\n        this.init();\n    }\n\n    private init(): void {\n        // Toggle click-through when hovering the character\n        this.character.addEventListener('mouseenter', () => {\n            window.deskmate.setIgnoreMouseEvents(false);\n        });\n\n        this.character.addEventListener('mouseleave', () => {\n            if (!this.isDragging) {\n                window.deskmate.setIgnoreMouseEvents(true);\n            }\n        });\n\n        this.character.addEventListener('mousedown', (e) => this.onMouseDown(e as MouseEvent));\n        window.addEventListener('mousemove', (e) => this.onMouseMove(e as MouseEvent));\n        window.addEventListener('mouseup', () => this.onMouseUp());\n    }\n\n    private async onMouseDown(e: MouseEvent): Promise<void> {\n        // Prevent drag if context menu (right click)\n        if (e.button === 2) return;\n\n        this.startMouse = { x: e.screenX, y: e.screenY };\n\n        // Get window position from main process\n        const [x, y] = await window.deskmate.getWindowPosition();\n        this.startWin = { x, y };\n\n        // Start dragging logic\n        this.isDragging = true;\n        this.hasMoved = false;\n\n        // Check for Quiet Mode via BehaviorEngine\n        // If quiet (sleep), DO NOT transition to 'drag' state, just move window purely\n\n        // MOVED TO onMouseMove to prevent \"click plays drag sound\"\n        // if (!this.getIsQuiet()) {\n        //     this.transitionTo('drag');\n        // }\n    }\n\n    private onMouseMove(e: MouseEvent): void {\n        if (!this.isDragging) return;\n\n        const dx = e.screenX - this.startMouse.x;\n        const dy = e.screenY - this.startMouse.y;\n\n        // Perform move immediately (fixes lag)\n        window.deskmate.setWindowPosition(this.startWin.x + dx, this.startWin.y + dy);\n\n        // Mark as moved if threshold exceeded (for sound distinction only)\n        if (!this.hasMoved && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {\n            this.hasMoved = true;\n\n            // Start Drag State (Sound/Anim) NOW\n            // Check quiet mode again to be safe\n            let isQuiet = false;\n            if (window.BehaviorEngine) {\n                const engine = (window as any).__modernSystem?.behaviorEngine;\n                if (engine && typeof engine.isQuietMode === 'function') {\n                    isQuiet = engine.isQuietMode();\n                }\n            }\n\n            if (!isQuiet) {\n                this.transitionTo('drag');\n            }\n        }\n\n        // Reset idle timer in scheduler if available\n        if (window.TriggerScheduler) {\n            // We can't access instance directly easily, but renderer keeps reference\n            // For now, we rely on mouse interaction resetting idle usage elsewhere or add explicit integration later\n        }\n    }\n\n    private onMouseUp(): void {\n        if (!this.isDragging) return;\n        this.isDragging = false;\n\n        // Dismiss any active notification\n        // Note: notificationManager is global in legacy system\n        if ((window as any).notificationManager) {\n            (window as any).notificationManager.dismiss();\n        }\n\n        // Check Quiet Mode\n        let isQuiet = false;\n        if (window.BehaviorEngine) {\n            const engine = (window as any).__modernSystem?.behaviorEngine;\n            if (engine && typeof engine.isQuietMode === 'function') {\n                isQuiet = engine.isQuietMode();\n            }\n        }\n\n        // Sound Logic: Click vs Drag (Jump)\n        if (this.hasMoved) {\n            // Dragged -> Land\n            // Only play if NOT quiet\n            if (!isQuiet) {\n                if (window.SoundManager) {\n                    const instance = (window as any).__modernSystem?.soundManager;\n                    // User requested to remove land sound to avoid repetition\n                    // if (instance) {\n                    //    instance.play('land');\n                    // }\n                } else if (typeof (window as any).playJumpSound === 'function') {\n                    // (window as any).playJumpSound();\n                }\n            }\n        } else {\n            // Stationary -> Click (Handled here to unify input logic)\n            // Interact Trigger\n            if (!isQuiet) {\n                // Determine interaction (default to click/interact)\n                this.transitionTo('interact');\n            } else {\n                console.log('[DragController] Click ignored (Quiet Mode)');\n            }\n        }\n\n        if (this.hasMoved) {\n            // Return to previous state or idle after Drag\n            this.revertState();\n        } else {\n            // Click interaction handles its own revert via BehaviorEngine config\n            // Do NOT force revert here\n        }\n    }\n\n    /**\n     * Helper to transition state using whatever engine is available\n     */\n    private transitionTo(state: string): void {\n        if (this.stateMachine && typeof this.stateMachine.transition === 'function') {\n            this.stateMachine.transition(state);\n        } else if (window.BehaviorEngine) {\n            const engine = (window as any).__modernSystem?.behaviorEngine;\n            if (engine) engine.transition(state);\n        }\n    }\n\n    private revertState(): void {\n        const sm = this.stateMachine;\n        if (sm) {\n            if (typeof sm.revert === 'function' && false) { // Disable revert history for Drag\n                sm.revert();\n            } else if (typeof sm.transition === 'function') {\n                sm.transition('idle');\n            }\n        }\n    }\n\n    /**\n     * Helper to check quiet mode safely\n     */\n    private getIsQuiet(): boolean {\n        // Check BehaviorEngine first (Modern)\n        if (window.BehaviorEngine) {\n            const engine = (window as any).__modernSystem?.behaviorEngine;\n            if (engine && typeof engine.isQuietMode === 'function') {\n                return engine.isQuietMode();\n            }\n        }\n        // Fallback to legacy if needed, or default false\n        return false;\n    }\n}\n","/**\n * DeskMate Renderer Process - TypeScript Entry Point\n * \n * This is the modern TypeScript entry point that will be bundled by Vite.\n * It imports and initializes the new modular architecture.\n * \n * @module renderer\n */\n\n// Import new modular components\nimport { BehaviorEngine } from './core/BehaviorEngine';\nimport { TriggerScheduler } from './core/TriggerScheduler';\nimport { SoundManager } from './audio/SoundManager';\nimport { EnergyManager } from './core/EnergyManager';\nimport { DragController } from './features/DragController';\n\n// Re-export for window global access (legacy compatibility)\ndeclare global {\n    interface Window {\n        BehaviorEngine: typeof BehaviorEngine;\n        TriggerScheduler: typeof TriggerScheduler;\n        SoundManager: typeof SoundManager;\n        EnergyManager: typeof EnergyManager;\n        DragController: typeof DragController;\n        deskmate: {\n            getSettings: () => Promise<any>;\n            getQuietMode: () => Promise<boolean>;\n            onQuietModeChanged: (callback: (enabled: boolean) => void) => void;\n            trackEvent: (name: string, data?: any) => void;\n            getCurrentSkin: () => Promise<any>;\n            getPetState: () => Promise<any>;\n            savePetState: (state: any) => Promise<any>;\n            t: (key: string) => Promise<string>;\n            [key: string]: any;\n        };\n    }\n}\n\n// Expose to window for legacy JS modules\nwindow.BehaviorEngine = BehaviorEngine;\nwindow.TriggerScheduler = TriggerScheduler;\nwindow.SoundManager = SoundManager;\nwindow.EnergyManager = EnergyManager;\nwindow.DragController = DragController;\n\n// ============================================\n// Global Error Handling (migrated from renderer.js)\n// ============================================\n\nwindow.onerror = function (message, source, lineno, colno, error) {\n    console.error('[Renderer Error]', message, '\\n  Source:', source, '\\n  Line:', lineno);\n    if (window.deskmate?.trackEvent) {\n        window.deskmate.trackEvent('js_error', { message, source, lineno });\n    }\n    return false;\n};\n\nwindow.onunhandledrejection = function (event) {\n    console.error('[Unhandled Promise Rejection]', event.reason);\n    if (window.deskmate?.trackEvent) {\n        window.deskmate.trackEvent('promise_rejection', {\n            message: event.reason?.message || String(event.reason)\n        });\n    }\n};\n\n// ============================================\n// Modern Init Function\n// ============================================\n\n/**\n * Initialize the modern behavior system\n * This runs alongside the legacy code during migration\n */\nasync function initModernSystem(): Promise<void> {\n    if ((window as any).__modernSystemInitialized) {\n        console.warn('[Renderer.ts] System already initialized, skipping');\n        return;\n    }\n    (window as any).__modernSystemInitialized = true;\n\n    console.log('[Renderer.ts] Initializing modern behavior system...');\n\n    // Get current skin config\n    const skinConfig = await window.deskmate.getCurrentSkin?.();\n\n    // Initialize SoundManager if skin has sounds\n    const soundManager = new SoundManager();\n    if (skinConfig?.sounds) {\n        await soundManager.loadSounds(skinConfig.sounds, skinConfig.basePath || '');\n        console.log('[Renderer.ts] SoundManager initialized');\n    }\n\n    // Initialize BehaviorEngine with skin behaviors\n    const behaviorEngine = new BehaviorEngine(skinConfig?.behaviors);\n    console.log('[Renderer.ts] BehaviorEngine initialized with states:', behaviorEngine.getValidStates());\n\n    // Initialize TriggerScheduler if triggers defined or for system triggers\n    let scheduler: TriggerScheduler | null = null;\n\n    if (skinConfig?.behaviors?.triggers) {\n        scheduler = new TriggerScheduler(behaviorEngine, skinConfig.behaviors.triggers);\n        console.log('[Renderer.ts] TriggerScheduler started with skin triggers');\n    } else {\n        // Start scheduler even without skin triggers to support system triggers (Phase 17)\n        scheduler = new TriggerScheduler(behaviorEngine, []);\n        console.log('[Renderer.ts] TriggerScheduler started (system triggers only)');\n    }\n\n    if (scheduler) {\n        scheduler.start();\n    }\n\n    // Initialize EnergyManager (Phase 17)\n    const energyManager = new EnergyManager();\n    await energyManager.init();\n\n    // Sync Initial Sound Settings (Global Mute)\n    try {\n        const soundEnabled = await window.deskmate.isSoundEnabled();\n        soundManager.setMuted(!soundEnabled);\n        console.log(`[Renderer.ts] Initial Sound Enabled: ${soundEnabled}`);\n    } catch (e) {\n        console.warn('[Renderer.ts] Failed to get initial sound setting', e);\n    }\n\n    // Listen for Settings Updates (Real-time Mute Toggle)\n    if (window.deskmate.onSettingsUpdated) {\n        window.deskmate.onSettingsUpdated((settings: any) => {\n            if (settings.sound && typeof settings.sound.enabled === 'boolean') {\n                const enabled = settings.sound.enabled;\n                soundManager.setMuted(!enabled);\n                // If unmuted and current state is looping (e.g. sleep), we might want to restart loop?\n                // But simplified logic: next state change will handle it, OR we can check current state.\n                const currentState = behaviorEngine.getCurrentState();\n                const config = soundManager.getConfig(currentState);\n                if (enabled && config?.loop && !soundManager.isLooping(currentState)) {\n                    soundManager.loop(currentState);\n                }\n            }\n        });\n    }\n\n    // Sound Debounce (Key: soundId, Value: timestamp)\n    const lastSoundTime = new Map<string, number>();\n\n    // Listen for stateChange events to play sounds\n    behaviorEngine.on('stateChange', (event) => {\n        if (event.type === 'stateChange') {\n            const data = event.data as { from: string; to: string };\n            console.log(`[Renderer.ts] State: ${data.from} -> ${data.to}`);\n\n            // Play state-specific sound if available\n            const stateSound = skinConfig?.sounds?.[data.to];\n\n            // Always stop previous loop when changing states\n            if (soundManager.isLooping(data.from) || soundManager.isLooping(data.to) || true) {\n                // Optimization: Stop loop unless state loop persists (not implemented yet)\n            }\n\n            // Check if new state has a configured sound\n            if (stateSound) {\n                const config = soundManager.getConfig(data.to);\n                if (config?.loop) {\n                    soundManager.loop(data.to);\n                } else {\n                    // Prevent duplicate one-shot sounds (Debounce 100ms)\n                    const now = Date.now();\n                    const lastTime = lastSoundTime.get(data.to) || 0;\n                    if (now - lastTime < 300) {\n                        console.warn(`[Renderer.ts] Debounced duplicate sound: ${data.to}`);\n                        return;\n                    }\n                    lastSoundTime.set(data.to, now);\n\n                    // New state has non-loop sound (one-shot entry sound)\n                    soundManager.stopLoop();\n                    soundManager.play(data.to);\n                }\n            } else {\n                // New state has NO sound -> Silence\n                soundManager.stopLoop();\n            }\n        }\n    });\n\n    // Sync Initial Quiet Mode\n    try {\n        const isQuiet = await window.deskmate.getQuietMode();\n        behaviorEngine.setQuietMode(isQuiet);\n        console.log(`[Renderer.ts] Initial Quiet Mode: ${isQuiet}`);\n    } catch (e) {\n        console.warn('[Renderer.ts] Failed to get initial quiet mode', e);\n    }\n\n    // Connect EnergyManager to TriggerScheduler\n    if (scheduler) {\n        // Set initial energy context\n        scheduler.setContext({ energy: energyManager.getEnergy() });\n\n        // Update context on change\n        energyManager.on('energyChange', (energy: number) => {\n            scheduler!.setContext({ energy });\n            // console.log('[Renderer.ts] Energy context updated:', energy);\n        });\n    }\n\n\n\n\n\n    // Initialize DragController (Phase 17)\n    // Pass stateMachine placeholder or null if it handles its own transitions via window.BehaviorEngine\n    // Note: Legacy passed stateMachine instance. New DragController can try to access window.BehaviorEngine fallback.\n    // However, clean architecture suggests we should pass an adapter.\n    // For now, let's instantiate it. It relies on DOM elements being present.\n    const dragController = new DragController(behaviorEngine);\n\n    // Expose instances for debugging\n    (window as any).__modernSystem = {\n        soundManager,\n        behaviorEngine,\n        energyManager,\n        scheduler,\n        dragController,\n    };\n\n    console.log('[Renderer.ts] Modern system ready (legacy system still active)');\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', initModernSystem);\n} else {\n    initModernSystem();\n}\n\nconsole.log('[Renderer.ts] TypeScript entry point loaded');\n"],"names":[],"mappings":"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"}